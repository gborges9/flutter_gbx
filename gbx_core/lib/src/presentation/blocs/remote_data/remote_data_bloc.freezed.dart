// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'remote_data_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$RemoteDataState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uninitialized,
    required TResult Function(T? data, LoadingType loadingType) loading,
    required TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)
        error,
    required TResult Function(T data, bool firstTimeLoaded) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UninitializedRemoteDataState<T> value)
        uninitialized,
    required TResult Function(LoadingRemoteDataState<T> value) loading,
    required TResult Function(ErrorRemoteDataState<T> value) error,
    required TResult Function(LoadedRemoteDataState<T> value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UninitializedRemoteDataState<T> value)? uninitialized,
    TResult Function(LoadingRemoteDataState<T> value)? loading,
    TResult Function(ErrorRemoteDataState<T> value)? error,
    TResult Function(LoadedRemoteDataState<T> value)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UninitializedRemoteDataState<T> value)? uninitialized,
    TResult Function(LoadingRemoteDataState<T> value)? loading,
    TResult Function(ErrorRemoteDataState<T> value)? error,
    TResult Function(LoadedRemoteDataState<T> value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RemoteDataStateCopyWith<T, $Res> {
  factory $RemoteDataStateCopyWith(
          RemoteDataState<T> value, $Res Function(RemoteDataState<T>) then) =
      _$RemoteDataStateCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$RemoteDataStateCopyWithImpl<T, $Res>
    implements $RemoteDataStateCopyWith<T, $Res> {
  _$RemoteDataStateCopyWithImpl(this._value, this._then);

  final RemoteDataState<T> _value;
  // ignore: unused_field
  final $Res Function(RemoteDataState<T>) _then;
}

/// @nodoc
abstract class _$$UninitializedRemoteDataStateCopyWith<T, $Res> {
  factory _$$UninitializedRemoteDataStateCopyWith(
          _$UninitializedRemoteDataState<T> value,
          $Res Function(_$UninitializedRemoteDataState<T>) then) =
      __$$UninitializedRemoteDataStateCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$UninitializedRemoteDataStateCopyWithImpl<T, $Res>
    extends _$RemoteDataStateCopyWithImpl<T, $Res>
    implements _$$UninitializedRemoteDataStateCopyWith<T, $Res> {
  __$$UninitializedRemoteDataStateCopyWithImpl(
      _$UninitializedRemoteDataState<T> _value,
      $Res Function(_$UninitializedRemoteDataState<T>) _then)
      : super(_value, (v) => _then(v as _$UninitializedRemoteDataState<T>));

  @override
  _$UninitializedRemoteDataState<T> get _value =>
      super._value as _$UninitializedRemoteDataState<T>;
}

/// @nodoc

class _$UninitializedRemoteDataState<T>
    extends UninitializedRemoteDataState<T> {
  const _$UninitializedRemoteDataState() : super._();

  @override
  String toString() {
    return 'RemoteDataState<$T>.uninitialized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UninitializedRemoteDataState<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uninitialized,
    required TResult Function(T? data, LoadingType loadingType) loading,
    required TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)
        error,
    required TResult Function(T data, bool firstTimeLoaded) loaded,
  }) {
    return uninitialized();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
  }) {
    return uninitialized?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
    required TResult orElse(),
  }) {
    if (uninitialized != null) {
      return uninitialized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UninitializedRemoteDataState<T> value)
        uninitialized,
    required TResult Function(LoadingRemoteDataState<T> value) loading,
    required TResult Function(ErrorRemoteDataState<T> value) error,
    required TResult Function(LoadedRemoteDataState<T> value) loaded,
  }) {
    return uninitialized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UninitializedRemoteDataState<T> value)? uninitialized,
    TResult Function(LoadingRemoteDataState<T> value)? loading,
    TResult Function(ErrorRemoteDataState<T> value)? error,
    TResult Function(LoadedRemoteDataState<T> value)? loaded,
  }) {
    return uninitialized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UninitializedRemoteDataState<T> value)? uninitialized,
    TResult Function(LoadingRemoteDataState<T> value)? loading,
    TResult Function(ErrorRemoteDataState<T> value)? error,
    TResult Function(LoadedRemoteDataState<T> value)? loaded,
    required TResult orElse(),
  }) {
    if (uninitialized != null) {
      return uninitialized(this);
    }
    return orElse();
  }
}

abstract class UninitializedRemoteDataState<T> extends RemoteDataState<T>
    implements IUninitialiazedState {
  const factory UninitializedRemoteDataState() =
      _$UninitializedRemoteDataState<T>;
  const UninitializedRemoteDataState._() : super._();
}

/// @nodoc
abstract class _$$LoadingRemoteDataStateCopyWith<T, $Res> {
  factory _$$LoadingRemoteDataStateCopyWith(_$LoadingRemoteDataState<T> value,
          $Res Function(_$LoadingRemoteDataState<T>) then) =
      __$$LoadingRemoteDataStateCopyWithImpl<T, $Res>;
  $Res call({T? data, LoadingType loadingType});
}

/// @nodoc
class __$$LoadingRemoteDataStateCopyWithImpl<T, $Res>
    extends _$RemoteDataStateCopyWithImpl<T, $Res>
    implements _$$LoadingRemoteDataStateCopyWith<T, $Res> {
  __$$LoadingRemoteDataStateCopyWithImpl(_$LoadingRemoteDataState<T> _value,
      $Res Function(_$LoadingRemoteDataState<T>) _then)
      : super(_value, (v) => _then(v as _$LoadingRemoteDataState<T>));

  @override
  _$LoadingRemoteDataState<T> get _value =>
      super._value as _$LoadingRemoteDataState<T>;

  @override
  $Res call({
    Object? data = freezed,
    Object? loadingType = freezed,
  }) {
    return _then(_$LoadingRemoteDataState<T>(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as T?,
      loadingType: loadingType == freezed
          ? _value.loadingType
          : loadingType // ignore: cast_nullable_to_non_nullable
              as LoadingType,
    ));
  }
}

/// @nodoc

class _$LoadingRemoteDataState<T> extends LoadingRemoteDataState<T> {
  _$LoadingRemoteDataState(
      {this.data, this.loadingType = LoadingType.initializing})
      : super._();

  @override
  final T? data;
  @override
  @JsonKey()
  final LoadingType loadingType;

  @override
  String toString() {
    return 'RemoteDataState<$T>.loading(data: $data, loadingType: $loadingType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadingRemoteDataState<T> &&
            const DeepCollectionEquality().equals(other.data, data) &&
            const DeepCollectionEquality()
                .equals(other.loadingType, loadingType));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(data),
      const DeepCollectionEquality().hash(loadingType));

  @JsonKey(ignore: true)
  @override
  _$$LoadingRemoteDataStateCopyWith<T, _$LoadingRemoteDataState<T>>
      get copyWith => __$$LoadingRemoteDataStateCopyWithImpl<T,
          _$LoadingRemoteDataState<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uninitialized,
    required TResult Function(T? data, LoadingType loadingType) loading,
    required TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)
        error,
    required TResult Function(T data, bool firstTimeLoaded) loaded,
  }) {
    return loading(data, loadingType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
  }) {
    return loading?.call(data, loadingType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(data, loadingType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UninitializedRemoteDataState<T> value)
        uninitialized,
    required TResult Function(LoadingRemoteDataState<T> value) loading,
    required TResult Function(ErrorRemoteDataState<T> value) error,
    required TResult Function(LoadedRemoteDataState<T> value) loaded,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UninitializedRemoteDataState<T> value)? uninitialized,
    TResult Function(LoadingRemoteDataState<T> value)? loading,
    TResult Function(ErrorRemoteDataState<T> value)? error,
    TResult Function(LoadedRemoteDataState<T> value)? loaded,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UninitializedRemoteDataState<T> value)? uninitialized,
    TResult Function(LoadingRemoteDataState<T> value)? loading,
    TResult Function(ErrorRemoteDataState<T> value)? error,
    TResult Function(LoadedRemoteDataState<T> value)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingRemoteDataState<T> extends RemoteDataState<T>
    implements ILoadingState<dynamic> {
  factory LoadingRemoteDataState(
      {final T? data,
      final LoadingType loadingType}) = _$LoadingRemoteDataState<T>;
  LoadingRemoteDataState._() : super._();

  T? get data;
  LoadingType get loadingType;
  @JsonKey(ignore: true)
  _$$LoadingRemoteDataStateCopyWith<T, _$LoadingRemoteDataState<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorRemoteDataStateCopyWith<T, $Res> {
  factory _$$ErrorRemoteDataStateCopyWith(_$ErrorRemoteDataState<T> value,
          $Res Function(_$ErrorRemoteDataState<T>) then) =
      __$$ErrorRemoteDataStateCopyWithImpl<T, $Res>;
  $Res call(
      {T? data,
      dynamic error,
      StackTrace? stackTrace,
      LoadingType loadingType,
      dynamic temporary});
}

/// @nodoc
class __$$ErrorRemoteDataStateCopyWithImpl<T, $Res>
    extends _$RemoteDataStateCopyWithImpl<T, $Res>
    implements _$$ErrorRemoteDataStateCopyWith<T, $Res> {
  __$$ErrorRemoteDataStateCopyWithImpl(_$ErrorRemoteDataState<T> _value,
      $Res Function(_$ErrorRemoteDataState<T>) _then)
      : super(_value, (v) => _then(v as _$ErrorRemoteDataState<T>));

  @override
  _$ErrorRemoteDataState<T> get _value =>
      super._value as _$ErrorRemoteDataState<T>;

  @override
  $Res call({
    Object? data = freezed,
    Object? error = freezed,
    Object? stackTrace = freezed,
    Object? loadingType = freezed,
    Object? temporary = freezed,
  }) {
    return _then(_$ErrorRemoteDataState<T>(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as T?,
      error: error == freezed
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as dynamic,
      stackTrace: stackTrace == freezed
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
      loadingType: loadingType == freezed
          ? _value.loadingType
          : loadingType // ignore: cast_nullable_to_non_nullable
              as LoadingType,
      temporary: temporary == freezed ? _value.temporary : temporary,
    ));
  }
}

/// @nodoc

class _$ErrorRemoteDataState<T> extends ErrorRemoteDataState<T> {
  const _$ErrorRemoteDataState(
      {this.data,
      this.error,
      this.stackTrace,
      this.loadingType = LoadingType.initializing,
      this.temporary = false})
      : super._();

  @override
  final T? data;
  @override
  final dynamic error;
  @override
  final StackTrace? stackTrace;
  @override
  @JsonKey()
  final LoadingType loadingType;
  @override
  @JsonKey()
  final dynamic temporary;

  @override
  String toString() {
    return 'RemoteDataState<$T>.error(data: $data, error: $error, stackTrace: $stackTrace, loadingType: $loadingType, temporary: $temporary)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorRemoteDataState<T> &&
            const DeepCollectionEquality().equals(other.data, data) &&
            const DeepCollectionEquality().equals(other.error, error) &&
            const DeepCollectionEquality()
                .equals(other.stackTrace, stackTrace) &&
            const DeepCollectionEquality()
                .equals(other.loadingType, loadingType) &&
            const DeepCollectionEquality().equals(other.temporary, temporary));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(data),
      const DeepCollectionEquality().hash(error),
      const DeepCollectionEquality().hash(stackTrace),
      const DeepCollectionEquality().hash(loadingType),
      const DeepCollectionEquality().hash(temporary));

  @JsonKey(ignore: true)
  @override
  _$$ErrorRemoteDataStateCopyWith<T, _$ErrorRemoteDataState<T>> get copyWith =>
      __$$ErrorRemoteDataStateCopyWithImpl<T, _$ErrorRemoteDataState<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uninitialized,
    required TResult Function(T? data, LoadingType loadingType) loading,
    required TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)
        error,
    required TResult Function(T data, bool firstTimeLoaded) loaded,
  }) {
    return error(data, this.error, stackTrace, loadingType, temporary);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
  }) {
    return error?.call(data, this.error, stackTrace, loadingType, temporary);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(data, this.error, stackTrace, loadingType, temporary);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UninitializedRemoteDataState<T> value)
        uninitialized,
    required TResult Function(LoadingRemoteDataState<T> value) loading,
    required TResult Function(ErrorRemoteDataState<T> value) error,
    required TResult Function(LoadedRemoteDataState<T> value) loaded,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UninitializedRemoteDataState<T> value)? uninitialized,
    TResult Function(LoadingRemoteDataState<T> value)? loading,
    TResult Function(ErrorRemoteDataState<T> value)? error,
    TResult Function(LoadedRemoteDataState<T> value)? loaded,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UninitializedRemoteDataState<T> value)? uninitialized,
    TResult Function(LoadingRemoteDataState<T> value)? loading,
    TResult Function(ErrorRemoteDataState<T> value)? error,
    TResult Function(LoadedRemoteDataState<T> value)? loaded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ErrorRemoteDataState<T> extends RemoteDataState<T>
    implements IErrorState<dynamic> {
  const factory ErrorRemoteDataState(
      {final T? data,
      final dynamic error,
      final StackTrace? stackTrace,
      final LoadingType loadingType,
      final dynamic temporary}) = _$ErrorRemoteDataState<T>;
  const ErrorRemoteDataState._() : super._();

  T? get data;
  dynamic get error;
  StackTrace? get stackTrace;
  LoadingType get loadingType;
  dynamic get temporary;
  @JsonKey(ignore: true)
  _$$ErrorRemoteDataStateCopyWith<T, _$ErrorRemoteDataState<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadedRemoteDataStateCopyWith<T, $Res> {
  factory _$$LoadedRemoteDataStateCopyWith(_$LoadedRemoteDataState<T> value,
          $Res Function(_$LoadedRemoteDataState<T>) then) =
      __$$LoadedRemoteDataStateCopyWithImpl<T, $Res>;
  $Res call({T data, bool firstTimeLoaded});
}

/// @nodoc
class __$$LoadedRemoteDataStateCopyWithImpl<T, $Res>
    extends _$RemoteDataStateCopyWithImpl<T, $Res>
    implements _$$LoadedRemoteDataStateCopyWith<T, $Res> {
  __$$LoadedRemoteDataStateCopyWithImpl(_$LoadedRemoteDataState<T> _value,
      $Res Function(_$LoadedRemoteDataState<T>) _then)
      : super(_value, (v) => _then(v as _$LoadedRemoteDataState<T>));

  @override
  _$LoadedRemoteDataState<T> get _value =>
      super._value as _$LoadedRemoteDataState<T>;

  @override
  $Res call({
    Object? data = freezed,
    Object? firstTimeLoaded = freezed,
  }) {
    return _then(_$LoadedRemoteDataState<T>(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as T,
      firstTimeLoaded: firstTimeLoaded == freezed
          ? _value.firstTimeLoaded
          : firstTimeLoaded // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$LoadedRemoteDataState<T> extends LoadedRemoteDataState<T> {
  const _$LoadedRemoteDataState(
      {required this.data, this.firstTimeLoaded = false})
      : super._();

  @override
  final T data;
  @override
  @JsonKey()
  final bool firstTimeLoaded;

  @override
  String toString() {
    return 'RemoteDataState<$T>.loaded(data: $data, firstTimeLoaded: $firstTimeLoaded)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedRemoteDataState<T> &&
            const DeepCollectionEquality().equals(other.data, data) &&
            const DeepCollectionEquality()
                .equals(other.firstTimeLoaded, firstTimeLoaded));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(data),
      const DeepCollectionEquality().hash(firstTimeLoaded));

  @JsonKey(ignore: true)
  @override
  _$$LoadedRemoteDataStateCopyWith<T, _$LoadedRemoteDataState<T>>
      get copyWith =>
          __$$LoadedRemoteDataStateCopyWithImpl<T, _$LoadedRemoteDataState<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uninitialized,
    required TResult Function(T? data, LoadingType loadingType) loading,
    required TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)
        error,
    required TResult Function(T data, bool firstTimeLoaded) loaded,
  }) {
    return loaded(data, firstTimeLoaded);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
  }) {
    return loaded?.call(data, firstTimeLoaded);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(data, firstTimeLoaded);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UninitializedRemoteDataState<T> value)
        uninitialized,
    required TResult Function(LoadingRemoteDataState<T> value) loading,
    required TResult Function(ErrorRemoteDataState<T> value) error,
    required TResult Function(LoadedRemoteDataState<T> value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(UninitializedRemoteDataState<T> value)? uninitialized,
    TResult Function(LoadingRemoteDataState<T> value)? loading,
    TResult Function(ErrorRemoteDataState<T> value)? error,
    TResult Function(LoadedRemoteDataState<T> value)? loaded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UninitializedRemoteDataState<T> value)? uninitialized,
    TResult Function(LoadingRemoteDataState<T> value)? loading,
    TResult Function(ErrorRemoteDataState<T> value)? error,
    TResult Function(LoadedRemoteDataState<T> value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class LoadedRemoteDataState<T> extends RemoteDataState<T>
    implements ILoadedState<dynamic> {
  const factory LoadedRemoteDataState(
      {required final T data,
      final bool firstTimeLoaded}) = _$LoadedRemoteDataState<T>;
  const LoadedRemoteDataState._() : super._();

  T get data;
  bool get firstTimeLoaded;
  @JsonKey(ignore: true)
  _$$LoadedRemoteDataStateCopyWith<T, _$LoadedRemoteDataState<T>>
      get copyWith => throw _privateConstructorUsedError;
}
