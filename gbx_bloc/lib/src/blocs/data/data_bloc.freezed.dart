// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'data_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$DataState<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uninitialized,
    required TResult Function(T? data, LoadingType loadingType) loading,
    required TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)
        error,
    required TResult Function(T data, bool firstTimeLoaded) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uninitialized,
    TResult? Function(T? data, LoadingType loadingType)? loading,
    TResult? Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult? Function(T data, bool firstTimeLoaded)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UninitializedDataState<T> value) uninitialized,
    required TResult Function(LoadingDataState<T> value) loading,
    required TResult Function(ErrorDataState<T> value) error,
    required TResult Function(LoadedDataState<T> value) loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UninitializedDataState<T> value)? uninitialized,
    TResult? Function(LoadingDataState<T> value)? loading,
    TResult? Function(ErrorDataState<T> value)? error,
    TResult? Function(LoadedDataState<T> value)? loaded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UninitializedDataState<T> value)? uninitialized,
    TResult Function(LoadingDataState<T> value)? loading,
    TResult Function(ErrorDataState<T> value)? error,
    TResult Function(LoadedDataState<T> value)? loaded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataStateCopyWith<T, $Res> {
  factory $DataStateCopyWith(
          DataState<T> value, $Res Function(DataState<T>) then) =
      _$DataStateCopyWithImpl<T, $Res, DataState<T>>;
}

/// @nodoc
class _$DataStateCopyWithImpl<T, $Res, $Val extends DataState<T>>
    implements $DataStateCopyWith<T, $Res> {
  _$DataStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$UninitializedDataStateCopyWith<T, $Res> {
  factory _$$UninitializedDataStateCopyWith(_$UninitializedDataState<T> value,
          $Res Function(_$UninitializedDataState<T>) then) =
      __$$UninitializedDataStateCopyWithImpl<T, $Res>;
}

/// @nodoc
class __$$UninitializedDataStateCopyWithImpl<T, $Res>
    extends _$DataStateCopyWithImpl<T, $Res, _$UninitializedDataState<T>>
    implements _$$UninitializedDataStateCopyWith<T, $Res> {
  __$$UninitializedDataStateCopyWithImpl(_$UninitializedDataState<T> _value,
      $Res Function(_$UninitializedDataState<T>) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UninitializedDataState<T> extends UninitializedDataState<T> {
  const _$UninitializedDataState() : super._();

  @override
  String toString() {
    return 'DataState<$T>.uninitialized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UninitializedDataState<T>);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uninitialized,
    required TResult Function(T? data, LoadingType loadingType) loading,
    required TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)
        error,
    required TResult Function(T data, bool firstTimeLoaded) loaded,
  }) {
    return uninitialized();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uninitialized,
    TResult? Function(T? data, LoadingType loadingType)? loading,
    TResult? Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult? Function(T data, bool firstTimeLoaded)? loaded,
  }) {
    return uninitialized?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
    required TResult orElse(),
  }) {
    if (uninitialized != null) {
      return uninitialized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UninitializedDataState<T> value) uninitialized,
    required TResult Function(LoadingDataState<T> value) loading,
    required TResult Function(ErrorDataState<T> value) error,
    required TResult Function(LoadedDataState<T> value) loaded,
  }) {
    return uninitialized(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UninitializedDataState<T> value)? uninitialized,
    TResult? Function(LoadingDataState<T> value)? loading,
    TResult? Function(ErrorDataState<T> value)? error,
    TResult? Function(LoadedDataState<T> value)? loaded,
  }) {
    return uninitialized?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UninitializedDataState<T> value)? uninitialized,
    TResult Function(LoadingDataState<T> value)? loading,
    TResult Function(ErrorDataState<T> value)? error,
    TResult Function(LoadedDataState<T> value)? loaded,
    required TResult orElse(),
  }) {
    if (uninitialized != null) {
      return uninitialized(this);
    }
    return orElse();
  }
}

abstract class UninitializedDataState<T> extends DataState<T>
    implements IUninitialiazedState {
  const factory UninitializedDataState() = _$UninitializedDataState<T>;
  const UninitializedDataState._() : super._();
}

/// @nodoc
abstract class _$$LoadingDataStateCopyWith<T, $Res> {
  factory _$$LoadingDataStateCopyWith(_$LoadingDataState<T> value,
          $Res Function(_$LoadingDataState<T>) then) =
      __$$LoadingDataStateCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T? data, LoadingType loadingType});
}

/// @nodoc
class __$$LoadingDataStateCopyWithImpl<T, $Res>
    extends _$DataStateCopyWithImpl<T, $Res, _$LoadingDataState<T>>
    implements _$$LoadingDataStateCopyWith<T, $Res> {
  __$$LoadingDataStateCopyWithImpl(
      _$LoadingDataState<T> _value, $Res Function(_$LoadingDataState<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
    Object? loadingType = null,
  }) {
    return _then(_$LoadingDataState<T>(
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as T?,
      loadingType: null == loadingType
          ? _value.loadingType
          : loadingType // ignore: cast_nullable_to_non_nullable
              as LoadingType,
    ));
  }
}

/// @nodoc

class _$LoadingDataState<T> extends LoadingDataState<T> {
  _$LoadingDataState({this.data, this.loadingType = LoadingType.fetching})
      : super._();

  @override
  final T? data;
  @override
  @JsonKey()
  final LoadingType loadingType;

  @override
  String toString() {
    return 'DataState<$T>.loading(data: $data, loadingType: $loadingType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadingDataState<T> &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.loadingType, loadingType) ||
                other.loadingType == loadingType));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(data), loadingType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadingDataStateCopyWith<T, _$LoadingDataState<T>> get copyWith =>
      __$$LoadingDataStateCopyWithImpl<T, _$LoadingDataState<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uninitialized,
    required TResult Function(T? data, LoadingType loadingType) loading,
    required TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)
        error,
    required TResult Function(T data, bool firstTimeLoaded) loaded,
  }) {
    return loading(data, loadingType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uninitialized,
    TResult? Function(T? data, LoadingType loadingType)? loading,
    TResult? Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult? Function(T data, bool firstTimeLoaded)? loaded,
  }) {
    return loading?.call(data, loadingType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(data, loadingType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UninitializedDataState<T> value) uninitialized,
    required TResult Function(LoadingDataState<T> value) loading,
    required TResult Function(ErrorDataState<T> value) error,
    required TResult Function(LoadedDataState<T> value) loaded,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UninitializedDataState<T> value)? uninitialized,
    TResult? Function(LoadingDataState<T> value)? loading,
    TResult? Function(ErrorDataState<T> value)? error,
    TResult? Function(LoadedDataState<T> value)? loaded,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UninitializedDataState<T> value)? uninitialized,
    TResult Function(LoadingDataState<T> value)? loading,
    TResult Function(ErrorDataState<T> value)? error,
    TResult Function(LoadedDataState<T> value)? loaded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingDataState<T> extends DataState<T>
    implements ILoadingState<dynamic> {
  factory LoadingDataState({final T? data, final LoadingType loadingType}) =
      _$LoadingDataState<T>;
  LoadingDataState._() : super._();

  T? get data;
  LoadingType get loadingType;
  @JsonKey(ignore: true)
  _$$LoadingDataStateCopyWith<T, _$LoadingDataState<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorDataStateCopyWith<T, $Res> {
  factory _$$ErrorDataStateCopyWith(
          _$ErrorDataState<T> value, $Res Function(_$ErrorDataState<T>) then) =
      __$$ErrorDataStateCopyWithImpl<T, $Res>;
  @useResult
  $Res call(
      {T? data,
      dynamic error,
      StackTrace? stackTrace,
      LoadingType loadingType,
      dynamic temporary});
}

/// @nodoc
class __$$ErrorDataStateCopyWithImpl<T, $Res>
    extends _$DataStateCopyWithImpl<T, $Res, _$ErrorDataState<T>>
    implements _$$ErrorDataStateCopyWith<T, $Res> {
  __$$ErrorDataStateCopyWithImpl(
      _$ErrorDataState<T> _value, $Res Function(_$ErrorDataState<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
    Object? error = null,
    Object? stackTrace = freezed,
    Object? loadingType = null,
    Object? temporary = null,
  }) {
    return _then(_$ErrorDataState<T>(
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as T?,
      error: null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as dynamic,
      stackTrace: freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
      loadingType: null == loadingType
          ? _value.loadingType
          : loadingType // ignore: cast_nullable_to_non_nullable
              as LoadingType,
      temporary: null == temporary ? _value.temporary : temporary,
    ));
  }
}

/// @nodoc

class _$ErrorDataState<T> extends ErrorDataState<T> {
  const _$ErrorDataState(
      {this.data,
      this.error,
      this.stackTrace,
      this.loadingType = LoadingType.fetching,
      this.temporary = false})
      : super._();

  @override
  final T? data;
  @override
  final dynamic error;
  @override
  final StackTrace? stackTrace;
  @override
  @JsonKey()
  final LoadingType loadingType;
  @override
  @JsonKey()
  final dynamic temporary;

  @override
  String toString() {
    return 'DataState<$T>.error(data: $data, error: $error, stackTrace: $stackTrace, loadingType: $loadingType, temporary: $temporary)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorDataState<T> &&
            const DeepCollectionEquality().equals(other.data, data) &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace) &&
            (identical(other.loadingType, loadingType) ||
                other.loadingType == loadingType) &&
            const DeepCollectionEquality().equals(other.temporary, temporary));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(data),
      const DeepCollectionEquality().hash(error),
      stackTrace,
      loadingType,
      const DeepCollectionEquality().hash(temporary));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorDataStateCopyWith<T, _$ErrorDataState<T>> get copyWith =>
      __$$ErrorDataStateCopyWithImpl<T, _$ErrorDataState<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uninitialized,
    required TResult Function(T? data, LoadingType loadingType) loading,
    required TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)
        error,
    required TResult Function(T data, bool firstTimeLoaded) loaded,
  }) {
    return error(data, this.error, stackTrace, loadingType, temporary);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uninitialized,
    TResult? Function(T? data, LoadingType loadingType)? loading,
    TResult? Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult? Function(T data, bool firstTimeLoaded)? loaded,
  }) {
    return error?.call(data, this.error, stackTrace, loadingType, temporary);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(data, this.error, stackTrace, loadingType, temporary);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UninitializedDataState<T> value) uninitialized,
    required TResult Function(LoadingDataState<T> value) loading,
    required TResult Function(ErrorDataState<T> value) error,
    required TResult Function(LoadedDataState<T> value) loaded,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UninitializedDataState<T> value)? uninitialized,
    TResult? Function(LoadingDataState<T> value)? loading,
    TResult? Function(ErrorDataState<T> value)? error,
    TResult? Function(LoadedDataState<T> value)? loaded,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UninitializedDataState<T> value)? uninitialized,
    TResult Function(LoadingDataState<T> value)? loading,
    TResult Function(ErrorDataState<T> value)? error,
    TResult Function(LoadedDataState<T> value)? loaded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ErrorDataState<T> extends DataState<T>
    implements IErrorState<dynamic> {
  const factory ErrorDataState(
      {final T? data,
      final dynamic error,
      final StackTrace? stackTrace,
      final LoadingType loadingType,
      final dynamic temporary}) = _$ErrorDataState<T>;
  const ErrorDataState._() : super._();

  T? get data;
  dynamic get error;
  StackTrace? get stackTrace;
  LoadingType get loadingType;
  dynamic get temporary;
  @JsonKey(ignore: true)
  _$$ErrorDataStateCopyWith<T, _$ErrorDataState<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadedDataStateCopyWith<T, $Res> {
  factory _$$LoadedDataStateCopyWith(_$LoadedDataState<T> value,
          $Res Function(_$LoadedDataState<T>) then) =
      __$$LoadedDataStateCopyWithImpl<T, $Res>;
  @useResult
  $Res call({T data, bool firstTimeLoaded});
}

/// @nodoc
class __$$LoadedDataStateCopyWithImpl<T, $Res>
    extends _$DataStateCopyWithImpl<T, $Res, _$LoadedDataState<T>>
    implements _$$LoadedDataStateCopyWith<T, $Res> {
  __$$LoadedDataStateCopyWithImpl(
      _$LoadedDataState<T> _value, $Res Function(_$LoadedDataState<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? firstTimeLoaded = null,
  }) {
    return _then(_$LoadedDataState<T>(
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as T,
      firstTimeLoaded: null == firstTimeLoaded
          ? _value.firstTimeLoaded
          : firstTimeLoaded // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$LoadedDataState<T> extends LoadedDataState<T> {
  const _$LoadedDataState({required this.data, this.firstTimeLoaded = false})
      : super._();

  @override
  final T data;
  @override
  @JsonKey()
  final bool firstTimeLoaded;

  @override
  String toString() {
    return 'DataState<$T>.loaded(data: $data, firstTimeLoaded: $firstTimeLoaded)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedDataState<T> &&
            const DeepCollectionEquality().equals(other.data, data) &&
            (identical(other.firstTimeLoaded, firstTimeLoaded) ||
                other.firstTimeLoaded == firstTimeLoaded));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(data), firstTimeLoaded);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedDataStateCopyWith<T, _$LoadedDataState<T>> get copyWith =>
      __$$LoadedDataStateCopyWithImpl<T, _$LoadedDataState<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() uninitialized,
    required TResult Function(T? data, LoadingType loadingType) loading,
    required TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)
        error,
    required TResult Function(T data, bool firstTimeLoaded) loaded,
  }) {
    return loaded(data, firstTimeLoaded);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? uninitialized,
    TResult? Function(T? data, LoadingType loadingType)? loading,
    TResult? Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult? Function(T data, bool firstTimeLoaded)? loaded,
  }) {
    return loaded?.call(data, firstTimeLoaded);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? uninitialized,
    TResult Function(T? data, LoadingType loadingType)? loading,
    TResult Function(T? data, dynamic error, StackTrace? stackTrace,
            LoadingType loadingType, dynamic temporary)?
        error,
    TResult Function(T data, bool firstTimeLoaded)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(data, firstTimeLoaded);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(UninitializedDataState<T> value) uninitialized,
    required TResult Function(LoadingDataState<T> value) loading,
    required TResult Function(ErrorDataState<T> value) error,
    required TResult Function(LoadedDataState<T> value) loaded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(UninitializedDataState<T> value)? uninitialized,
    TResult? Function(LoadingDataState<T> value)? loading,
    TResult? Function(ErrorDataState<T> value)? error,
    TResult? Function(LoadedDataState<T> value)? loaded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(UninitializedDataState<T> value)? uninitialized,
    TResult Function(LoadingDataState<T> value)? loading,
    TResult Function(ErrorDataState<T> value)? error,
    TResult Function(LoadedDataState<T> value)? loaded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class LoadedDataState<T> extends DataState<T>
    implements ILoadedState<dynamic> {
  const factory LoadedDataState(
      {required final T data,
      final bool firstTimeLoaded}) = _$LoadedDataState<T>;
  const LoadedDataState._() : super._();

  T get data;
  bool get firstTimeLoaded;
  @JsonKey(ignore: true)
  _$$LoadedDataStateCopyWith<T, _$LoadedDataState<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
